// Blue Nokia 5110
// ---------------
// Signal        (Nokia 5110) LaunchPad pin
// Reset         (RST, pin 1) connected to PA7
// SSI0Fss       (CE,  pin 2) connected to PA3
// Data/Command  (DC,  pin 3) connected to PA6
// SSI0Tx        (Din, pin 4) connected to PA5
// SSI0Clk       (Clk, pin 5) connected to PA2
// 3.3V          (Vcc, pin 6) power
// back light    (BL,  pin 7) not connected, consists of 4 white LEDs which draw ~80mA total
// Ground        (Gnd, pin 8) ground


#include "D:/college/3rd year/second term/lab/Labware/tm4c123gh6pm.h"
#include "Nokia5110.h"
#include "Random.h"
#include "TExaS.h"
#include <limits.h>
#include <time.h>
#include <stdlib.h>


void DisableInterrupts(void); // Disable interrupts
void EnableInterrupts(void);  // Enable interrupts
void WaitForInterrupt(void);
unsigned long TimerCount;
unsigned long Semaphore;
unsigned long sw1, sw2, col = 0, coln;
short h[7] = {5,5,5,5,5,5,5};
short grid[6][7];
int maxDepth = 6, nextMoveLocation = -1;
int r, res, wait = 10, gameOver = 0;
// Images 

const unsigned char logo[] ={
	0x42, 0x4D, 0x4A, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0xD4, 0x03, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x80, 0x00, 0x00, 0x07, 0x77, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x80, 0x00, 0x00, 0x08, 0xF8, 0xF7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x08, 0x88, 0x80, 0x00, 0x00, 0x88, 0x88, 0x88, 0x00, 0x03, 0x00, 0x00, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x88,
 0x88, 0x00, 0x88, 0x88, 0x8F, 0x00, 0x8F, 0xF7, 0x00, 0x0F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x80, 0x78, 0x88,
 0xFF, 0x07, 0xFF, 0xFF, 0x00, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x88, 0x88, 0x80, 0x07, 0x8F, 0xF0, 0x07, 0xF8, 0x7F,
 0x00, 0x88, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xF7, 0x0F, 0x00, 0x88, 0x30, 0x88,
 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xF7, 0x08, 0x00, 0x88, 0x88, 0x8F, 0x70, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x00, 0x00, 0x00, 0x07, 0x88, 0x70, 0x0F, 0xF0, 0x08, 0x08, 0x80, 0x0F, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x80, 0x00, 0x00, 0x78, 0x88, 0x88, 0x0F, 0xF0, 0x0F, 0x08, 0x80, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x88, 0x88, 0x88, 0x88, 0x00, 0xFF, 0x88, 0x8F, 0x00, 0x00, 0x08, 0x08, 0x80, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88, 0x88,
 0x88, 0x00, 0x88, 0x88, 0xF8, 0x00, 0x00, 0x00, 0x08, 0x88, 0x7F, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x88,
 0xF7, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x70, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x28, 0x87, 0x70, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80, 0x07, 0x07, 0x70, 0x08, 0x70,
 0x7F, 0x8F, 0x70, 0x07, 0x78, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x88, 0x88, 0xF8, 0x70, 0x00, 0x00, 0x00, 0x08, 0x80, 0x08, 0x07, 0x80, 0x88, 0x70, 0x7F, 0x87, 0x70, 0x88,
 0x88, 0x80, 0x00, 0xF7, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0x77, 0x78, 0x70, 0x00, 0x88, 0x73, 0x0F, 0x80, 0x88, 0x07, 0x70, 0x88, 0x70, 0x78, 0x00, 0x08, 0xF8, 0x77, 0x80, 0x00, 0xF7,
 0x00, 0x00, 0x00, 0x00, 0x07, 0xF8, 0x87, 0x00, 0x07, 0x70, 0x08, 0x88, 0x88, 0x08, 0x88, 0x88, 0x07, 0x78, 0x88, 0x70, 0x7F, 0x88, 0x08, 0xF7, 0x00, 0x00, 0x00, 0xF7, 0x00, 0x00, 0x00, 0x00,
 0x77, 0x88, 0x87, 0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x08, 0x88, 0x88, 0x07, 0x88, 0x87, 0x70, 0x7F, 0xF8, 0x08, 0xF7, 0x00, 0x00, 0x00, 0xF7, 0x00, 0x00, 0x00, 0x00, 0x68, 0x88, 0x70, 0x00,
 0x00, 0x00, 0x88, 0x88, 0x88, 0x08, 0x88, 0x88, 0x07, 0x88, 0x00, 0x70, 0x88, 0x70, 0x08, 0xF7, 0x00, 0x20, 0x00, 0xF7, 0x00, 0x00, 0x00, 0x00, 0x68, 0x88, 0x70, 0x00, 0x00, 0x00, 0x08, 0x88,
 0x87, 0x08, 0x88, 0x08, 0x08, 0x87, 0x00, 0x80, 0xF8, 0x77, 0x08, 0xF7, 0x33, 0x00, 0x08, 0xF8, 0x70, 0x00, 0x00, 0x00, 0x68, 0x88, 0x70, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x08, 0x80, 0x08,
 0x07, 0xF7, 0x03, 0x80, 0x7F, 0x88, 0x00, 0xFF, 0x78, 0x00, 0x8F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x78, 0x88, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x80, 0x00, 0x00,
 0x8F, 0xFF, 0x70, 0x8F, 0xFF, 0x00, 0xFF, 0x88, 0xF7, 0x00, 0x00, 0x00, 0x08, 0x8F, 0xF7, 0x00, 0x06, 0x70, 0x00, 0x08, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xF7, 0x00, 0x07, 0x70, 0x78, 0x8F, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0x8E, 0x70, 0x68, 0x00, 0x78, 0x88, 0x88, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x0F, 0x8E, 0x88, 0xF8, 0x00, 0x78, 0x88, 0x88, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x78, 0x87,
 0x70, 0x00, 0x7F, 0x88, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xFF,
 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,

};





const unsigned char player1[] ={
 0x42, 0x4D, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x0F,
 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF,

};



const unsigned char player2[] ={
 0x42, 0x4D, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00,
 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF,

};


const unsigned char empty_slot[] ={
 0x42, 0x4D, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xF0, 0x00,
 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF,

};



 const unsigned char cursor[] ={
 0x42, 0x4D, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,
 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF,

};












//  Functions declaration 

void PortF_Init(void);
void Init_Interrupt(void);
void GPIOPortF_Handler(void);
void UART_Init(void);
void UART1_Init(void);
unsigned char UART_InChar(void);
void UART_OutChar(unsigned char);
void Delay100ms(unsigned long count);
void Timer2_Init(unsigned long period);
int startGame(void);
unsigned long selectMode(void);
void displayGrid(void);
int minimax(int, int, int, int);
int isLegalMove(int);
int placeMove(int, int);
void undoMove(int);
int evaluateBoard(void);
int max(int, int);
int min(int, int);
int calculateScore(int, int);
int getAIMove(void);
int gameResult(void);
int displayResult(int);
void myMove(void);
void opponentMove(int);

int main(void){
	int AIMove, gameMode;
	unsigned char p1, p2;
  TExaS_Init(SSI0_Real_Nokia5110_Scope);  // set system clock to 80 MHz
  Random_Init(1);
	PortF_Init();
	UART1_Init();
	srand(0);
  Nokia5110_Init();
	gameMode = startGame();  //sw1 --> mode 1(1 player) , sw2--> mode2 (2players)
	EnableInterrupts();
	Init_Interrupt();      
	if (gameMode == 1){
		r = 1+rand()%2;           
		displayGrid();
		if(r == 1)myMove();  
		AIMove = 3;              //AI always in the same place middle column of first play
		grid[h[AIMove]][AIMove] = 1;
		h[AIMove] --;
	  	r = 1;
		displayGrid();          
		while (1){
			myMove();
			res = gameResult();     //1 if AI wins ,2 if human wins
			if(displayResult(res) == 1)return 0;  //if game is ended
			opponentMove(gameMode);      //AI play
			res = gameResult();          //update res after his play
			if(displayResult(res) == 1)return 0;  //if game is ended
		}
	}
	
	else {  //if multiplayer
		Nokia5110_Clear();
		Nokia5110_SetCursor(0,3);
		Nokia5110_OutString("Connecting..");
		Delay100ms(wait);
		p1 = rand()%10;                                                                                 ;
		UART_OutChar(p1);     //transmit move to the other kit
		p2 = UART_InChar();   //receive move from the other kit
		Nokia5110_Clear();        
		if (p1 > p2){
			Nokia5110_SetCursor(2,2);
			Nokia5110_OutString("YOU WILL");
			Nokia5110_SetCursor(3,3);
			Nokia5110_OutString("START");
			r = 1;
		}
		
		else {
			Nokia5110_SetCursor(0,2);
			Nokia5110_OutString("YOU WILL NOT");
			Nokia5110_SetCursor(3,3);
			Nokia5110_OutString("START");
			r = 2;
		}
		
		Delay100ms(wait);
		displayGrid();
		while(!gameOver){
			if(r == 1){   //if iam the starter
				myMove();   
				UART_OutChar((col+1)+'0'); //transmit to the other kit
				res = gameResult();        
				if(displayResult(res) == 1)return 0; //if game is ended
				//Timer2_Init(1000000000);
			}
			opponentMove(gameMode);   
			res = gameResult();
			if(displayResult(res) == 1)return 0;
			
			
		}
	}

}
//functions definition
void PortF_Init(void){ volatile unsigned long delay;
  SYSCTL_RCGC2_R |= 0x00000020;     // 1) F clock
  delay = SYSCTL_RCGC2_R;           // delay   
  GPIO_PORTF_LOCK_R = 0x4C4F434B;   // 2) unlock PortF PF0  
  GPIO_PORTF_CR_R = 0x1F;           // allow changes to PF4-0       
  GPIO_PORTF_AMSEL_R = 0x00;        // 3) disable analog function
  GPIO_PORTF_PCTL_R = 0x00000000;   // 4) GPIO clear bit PCTL  
  GPIO_PORTF_DIR_R = 0x0E;          // 5) PF4,PF0 input, PF3,PF2,PF1 output   
  GPIO_PORTF_AFSEL_R = 0x00;        // 6) no alternate function
  GPIO_PORTF_PUR_R = 0x11;          // enable pullup resistors on PF4,PF0       
  GPIO_PORTF_DEN_R = 0x1F;          // 7) enable digital pins PF4-PF0        
}

void Init_Interrupt(void){
	SYSCTL_RCGC2_R |= 0x00000020; // (a) activate clock for port F
  GPIO_PORTF_DIR_R &= ~0x11;    // (c) make PF0,PF4 in (built-in button)
  GPIO_PORTF_AFSEL_R &= ~0x11;  //     disable alt funct on PF4, PF0
  GPIO_PORTF_DEN_R |= 0x11;     //     enable digital I/O on PF4 , PF0  
  GPIO_PORTF_PCTL_R &= ~0x000F000F; // configure PF4 as GPIO
  GPIO_PORTF_AMSEL_R = 0;       //     disable analog functionality on PF
  GPIO_PORTF_PUR_R |= 0x11;     //     enable weak pull-up on PF4, PF0
  GPIO_PORTF_IS_R &= ~0x11;     // (d) PF0, PF4 is edge-sensitive
  GPIO_PORTF_IBE_R &= ~0x11;    //     PF0, PF4 is not both edges
  GPIO_PORTF_IEV_R &= ~0x11;    //     PF0, PF4 falling edge event
  GPIO_PORTF_ICR_R |= 0x11;      // (e) clear flag0,4
  GPIO_PORTF_IM_R |= 0x11;      // (f) arm interrupt on PF4, PF0
  NVIC_PRI7_R = (NVIC_PRI7_R&0xFF00FFFF)|0x00A00000; // (g) priority 5
  NVIC_EN0_R |= (1<<30);      // (h) enable interrupt 30 in NVIC
  EnableInterrupts(); 
}
void GPIOPortF_Handler(void){
	if (GPIO_PORTF_RIS_R&(1<<0)){
		GPIO_PORTF_ICR_R |= (1<<0);
		if (r == 1){
			if (col < 6)col ++;
			else col = 0;
			displayGrid();
		}
	}
	else if (GPIO_PORTF_RIS_R&(1<<4)){
		GPIO_PORTF_ICR_R |= (1<<4);
		if (isLegalMove(col) && r == 1){
			grid[h[col]][col] = 2;
			h[col]--;
			r = 2;
		}
		
	}
}
void UART1_Init(void){
  SYSCTL_RCGC1_R |= SYSCTL_RCGC1_UART1; // activate UART1
  SYSCTL_RCGC2_R |= SYSCTL_RCGC2_GPIOB; // activate port B
  UART1_CTL_R &= ~UART_CTL_UARTEN;      // disable UART
  UART1_IBRD_R = 43;                    
  UART1_FBRD_R = 26;                     
                                        // 8 bit word length (no parity bits, one stop bit, FIFOs)
  UART1_LCRH_R = (UART_LCRH_WLEN_8|UART_LCRH_FEN);
  UART1_CTL_R |= UART_CTL_UARTEN;       // enable UART
  GPIO_PORTB_AFSEL_R |= 0x03;           // enable alt funct on PB1-0
  GPIO_PORTB_DEN_R |= 0x03;             // enable digital I/O on PB1-0
                                        // configure PB1-0 as UART
  GPIO_PORTB_PCTL_R = (GPIO_PORTB_PCTL_R&0xFFFFFF00)+0x00000011;
  GPIO_PORTB_AMSEL_R &= ~0x03;          // disable analog functionality on PB
}
unsigned char UART_InChar(void){
  while((UART1_FR_R&UART_FR_RXFE) != 0);
  return((unsigned char)(UART1_DR_R&0xFF));
}
void UART_OutChar(unsigned char data){
  while((UART1_FR_R&UART_FR_TXFF) != 0);
  UART1_DR_R = data;
}
void Delay100ms(unsigned long count){unsigned long volatile time;
  while(count>0){
    time = 727240;  // 0.1sec at 80 MHz
    while(time){
	  	time--;
    }
    count--;
  }
}
void Timer2_Init(unsigned long period){ 
  unsigned long volatile delay;
  SYSCTL_RCGCTIMER_R |= 0x04;   // 0) activate timer2
  delay = SYSCTL_RCGCTIMER_R;
  TimerCount = 0;
  Semaphore = 0;
  TIMER2_CTL_R = 0x00000000;    // 1) disable timer2A during setup
  TIMER2_CFG_R = 0x00000000;    // 2) configure for 32-bit mode
  TIMER2_TAMR_R = 0x00000002;   // 3) configure for periodic mode, default down-count settings
  TIMER2_TAILR_R = period-1;    // 4) reload value
  TIMER2_TAPR_R = 0;            // 5) bus clock resolution
  TIMER2_ICR_R = 0x00000001;    // 6) clear timer2A timeout flag
  TIMER2_IMR_R = 0x00000001;    // 7) arm timeout interrupt
  NVIC_PRI5_R = (NVIC_PRI5_R&0x00FFFFFF)|0x80000000; // 8) priority 4
// interrupts enabled in the main program after all devices initialized
// vector number 39, interrupt number 23
  NVIC_EN0_R = 1<<23;           // 9) enable IRQ 23 in NVIC
  TIMER2_CTL_R = 0x00000001;    // 10) enable timer2A
}
void Timer2A_Handler(void){ 
  TIMER2_ICR_R = 0x00000001;   // acknowledge timer2A timeout
  if(r != 1){
		Nokia5110_Clear();
		Nokia5110_SetCursor(4,2);
		Nokia5110_OutString("GAME");
		Nokia5110_SetCursor(4,3);
		Nokia5110_OutString("HELD:)");
		gameOver = 1;
	}
}
int startGame(void){
	int m;
	Nokia5110_PrintBMP(10, 35, logo, 2);
	Nokia5110_DisplayBuffer();
	Delay100ms(wait);
	Nokia5110_ClearBuffer();
	Nokia5110_Clear();
	Nokia5110_SetCursor(1,0);
	Nokia5110_OutString("Select Mode");
	Nokia5110_SetCursor(1,2);
	Nokia5110_OutString("<< 1  2 >>");
	Nokia5110_SetCursor(3,4);
	Nokia5110_OutString("Player");
  m = selectMode();
	while(!m){
		m = selectMode();  //1 if 1player, 2 if 2players
	}
	return m;
}

unsigned long selectMode(void){
	unsigned long mode = 0;
	sw1 = GPIO_PORTF_DATA_R&(1<<4);
	sw2 = GPIO_PORTF_DATA_R&(1<<0);
	if (!sw1)mode = 1;   //1player
	else if (!sw2)mode = 2;    //2players
	return mode;

}	

void displayGrid(void){
	int xpos, ypos, i, j;
	Nokia5110_Clear();
	Nokia5110_ClearBuffer();
	Nokia5110_PrintBMP((col)*10+6 , 10 , cursor, 0);
	ypos=17;
	for(i=0;i<6;i++){   //no of rows 
			xpos=6;
		for(j=0;j<7;j++){
	if(grid[i][j]==1)
		Nokia5110_PrintBMP(xpos,ypos, player1, 0);
	else if(grid[i][j]==2)
		Nokia5110_PrintBMP(xpos,ypos, player2, 0);
	else
		Nokia5110_PrintBMP(xpos,ypos, empty_slot, 0);
			xpos=xpos+10;
		}
			ypos=ypos+6;
	}
	Nokia5110_DisplayBuffer();
	Nokia5110_SetCursor(1,0);
	if (r == 1)
	{
		Nokia5110_SetCursor(1,0);
		Nokia5110_OutString("YOUR TURN");
	
	}
	else {
		Nokia5110_SetCursor(0,0);
		Nokia5110_OutString("PLAYER2 TURN");
	}
}

int minimax(int depth, int turn, int alpha, int beta){
	int Result, maxScore, minScore, j;
  if(beta<=alpha){
		if(turn == 1) return INT_MAX;
		else return INT_MIN; 
	}
	Result = gameResult();
	
	if(Result==1)return INT_MAX/2;         
	else if(Result==2)return INT_MIN/2;
	else if(Result==0)return 0; 
	
	if(depth==maxDepth)return evaluateBoard(); //if depth = 6 ,if the column is full
	
	maxScore=INT_MIN;
	minScore = INT_MAX;
					
	for(j=0;j<=6;++j){  //for columns 
			
			int currentScore = 0;
			
			if(!isLegalMove(j)) continue; 
			
			if(turn==1){   // AI player
							placeMove(j, 1); //place AI player in the same column 
							currentScore = minimax(depth+1, 2, alpha, beta); //recursion with incrementing the depth 
							
							if(depth==0){
									if(currentScore > maxScore)nextMoveLocation = j; 
									if(currentScore == INT_MAX/2){
									undoMove(j);
									break;
									}
							}
							
							maxScore = max(currentScore, maxScore);
							alpha = max(currentScore, alpha);  
			} 
			else if(turn==2){ //human player
							placeMove(j, 2);
							currentScore = minimax(depth+1, 1, alpha, beta);
							minScore = min(currentScore, minScore);
							beta = min(currentScore, beta); 
			}  
			undoMove(j); 
			if(currentScore == INT_MAX || currentScore == INT_MIN) break; 
	}  
	if( turn==1)
		return maxScore;
	else
	return minScore;

}
int isLegalMove(int column){
  if(grid[0][column]==0)return 1;  //if the column is not full its a legal move (cell in the last row is empty)
	else return 0;
}
int placeMove(int column, int player){ 
	int i;
	if(!isLegalMove(column)) {return 0;} //its not legal to play in this column
	for(i=5;i>=0;--i){                   //rows in the same column
			if(grid[i][column] == 0) {       
					grid[i][column] = (short)player;  //play in the same cell 
					return 1;
			}
	}
	return 0;
}
void undoMove(int column){
	int i;
	for(i=0;i<=5;++i){
			if(grid[i][column] != 0) {
					grid[i][column] = 0;
					break;
			}
	}        
}
int evaluateBoard(){ 
	int aiScore=1;      
	int score=0;
	int blanks = 0;
	int k=0, moreMoves=0;
	int i, j, c, m;
	for(i=5;i>=0;--i){    //for rows
		for(j=0;j<=6;++j){  //for columns
				
			if(grid[i][j]==0 || grid[i][j]==2) continue; //if cell is empty or filled with human player 
			
			if(j<=3){   //for columns in the same row from left to right
				for(k=1;k<4;++k){
						if(grid[i][j+k]==1)aiScore++;  //next cell in the same row is AI
						else if(grid[i][j+k]==2){     //next cell in the same row is human 
							aiScore=0;                  // ai is zero for the same row
						  blanks =0;
						  break;
						
						}
						
						else blanks++;    //increment blank cells
						
				}	 
				moreMoves = 0;         
				if(blanks>0) 
						for(c=1;c<4;++c){
								int column = j+c;       //maximum number of columns =7 
								for(m=i; m<= 5;m++){     
								 if(grid[m][column]==0)moreMoves++;
										else break;
								} 
						} 
				
				if(moreMoves!=0) score += calculateScore(aiScore, moreMoves); 
				aiScore=1;   
				blanks = 0;
			}
			
			if(i>=3){   //for rows 5-->3 from bottom to top
				for(k=1;k<4;++k){
						if(grid[i-k][j]==1)aiScore++;   //next cell in the same column (upper) is AI
						else if(grid[i-k][j]==2){aiScore=0;break;} //next cell in the same column (upper) is human
				} 
				moreMoves = 0;  
				
				if(aiScore>0){       //two cells are the same in the same column
						int column = j;
						for(m=i-k+1; m<=i-1;m++){
						 if(grid[m][column]==0)moreMoves++;
								else break;
						}  
				}
				if(moreMoves!=0) score += calculateScore(aiScore, moreMoves);
				aiScore=1;  
				blanks = 0;
			}
			 
			if(j>=3){ //the same row from right to left
				for(k=1;k<4;++k){ 
					if(grid[i][j-k]==1)aiScore++;  //cells are the same in the same row is AI
					else if(grid[i][j-k]==2){aiScore=0; blanks=0;break;}
					else blanks++;
				}
				moreMoves=0;
				if(blanks>0) 
					for(c=1;c<4;++c){
						int column = j- c;  //cells in the same Row
						for(m=i; m<= 5;m++){
						 if(grid[m][column]==0)moreMoves++;
								else break;
						} 
					} 
				
				if(moreMoves!=0) score += calculateScore(aiScore, moreMoves);
				aiScore=1; 
				blanks = 0;
			}
			 
			if(j<=3 && i>=3){    //cells in the same diagonal from bottom left
				for(k=1;k<4;++k){
					if(grid[i-k][j+k]==1)aiScore++; 
					else if(grid[i-k][j+k]==2){aiScore=0;blanks=0;break;}  
					else blanks++;                        
				}
				moreMoves=0;
				if(blanks>0){
					for(c=1;c<4;++c){
						int column = j+c, row = i-c;
						for(m=row;m<=5;++m){
							if(grid[m][column]==0)moreMoves++;
							else if(grid[m][column]==1);
							else break;
						}
					} 
						if(moreMoves!=0) score += calculateScore(aiScore, moreMoves);
						aiScore=1;
						blanks = 0;
				}
			}
			 
			if(i>=3 && j>=3){ // diagonal from top right
					for(k=1;k<4;++k){
							if(grid[i-k][j-k]==1)aiScore++;
							else if(grid[i-k][j-k]==2){aiScore=0;blanks=0;break;}
							else blanks++;                        
					}
					moreMoves=0;
					if(blanks>0){
							for(c=1;c<4;++c){
									int column = j-c, row = i-c;
									for(m=row;m<=5;++m){
											if(grid[m][column]==0)moreMoves++;
											else if(grid[m][column]==1);
											else break;
									}
							} 
							if(moreMoves!=0) score += calculateScore(aiScore, moreMoves);
							aiScore=1;
							blanks = 0;
					}
			} 
	}
	}
	return score;
}
int getAIMove(){ //when AI PLAY
	nextMoveLocation = -1;
	minimax(0, 1, INT_MIN, INT_MAX);
	return nextMoveLocation;
}
int max(int x, int y){ //return maximum between two values
	if (x > y)return x;
	else return y;
}
int min(int x, int y){ //return minimum between two values
	if (x < y)return x;
	else return y;
}
int calculateScore(int aiScore, int moreMoves){   
	int moveScore = 4 - moreMoves;
	if(aiScore==0)return 0;
	else if(aiScore==1)return 1*moveScore;
	else if(aiScore==2)return 10*moveScore;
	else if(aiScore==3)return 100*moveScore;
	else return 1000;
	
}

int gameResult(){
	int aiScore = 0, humanScore = 0, i, j, k;
	for(i=5;i>=0;--i){  //for rows 
		for(j=0;j<=6;++j){   //for columns
			if(grid[i][j]==0) continue;
			
			//Checking cells to the right
			if(j<=3){
				for(k=0;k<4;++k){ 
					if(grid[i][j+k]==1) aiScore++;
					else if(grid[i][j+k]==2) humanScore++;
					else break; 
				}
				if(aiScore==4)return 1;
				else if (humanScore==4)return 2;
				aiScore = 0;
				humanScore = 0;
			} 
			
			//Checking cells up 
			if(i>=3){
				for(k=0;k<4;++k){
					if(grid[i-k][j]==1) aiScore++;
					else if(grid[i-k][j]==2) humanScore++;
					else break;
				}
				if(aiScore==4)return 1; 
				else if (humanScore==4)return 2;
				aiScore = 0;
				humanScore = 0;
			} 
			
			//Checking diagonal up-right
			if(j<=3 && i>= 3){
				for(k=0;k<4;++k){
					if(grid[i-k][j+k]==1) aiScore++;
					else if(grid[i-k][j+k]==2) humanScore++;
					else break;
				}
				if(aiScore==4)return 1; else if (humanScore==4)return 2;
				aiScore = 0; humanScore = 0;
			}
			
			//Checking diagonal up-left
			if(j>=3 && i>=3){
				for(k=0;k<4;++k){
					if(grid[i-k][j-k]==1) aiScore++;
					else if(grid[i-k][j-k]==2) humanScore++;
					else break;
				} 
				if(aiScore==4)return 1; else if (humanScore==4)return 2;
				aiScore = 0; humanScore = 0;
			}  
		}
	}
	
	for(j=0;j<7;++j){
			//Game has not ended yet
			if(grid[1][j]==0)return -1;
	}
	//Game draw!
	return 0;
}
int displayResult(int R){
	int ended = 0;
	if (R == 2){  // if human wins
		Delay100ms(wait);
		Nokia5110_Clear();
		Nokia5110_SetCursor(4,2);
		Nokia5110_OutString("YOU");
		Nokia5110_SetCursor(4,3);
		Nokia5110_OutString("WIN ^_^");
		ended = 1;
	}
	else if(R == 1){  // if AI wins
		Delay100ms(wait);
		Nokia5110_Clear();
		Nokia5110_SetCursor(4,2);
		Nokia5110_OutString("YOU");
		Nokia5110_SetCursor(3,3);
		Nokia5110_OutString("LOSE!");
		ended = 1;
	}
	else if (R == 0){  //if game is draw no one wins
		Delay100ms(wait);
		Nokia5110_Clear();
		Nokia5110_SetCursor(4,2);
		Nokia5110_OutString("DRAW!");
		ended = 1;
	}
	return ended;
} 
void myMove(void){
	while (r == 1){  
		WaitForInterrupt();
	}
	displayGrid();
	
}
void opponentMove(int mode){
	int opMove;
	if (mode == 1)opMove = getAIMove();
	else opMove = (UART_InChar()-'0')-1;
	r = 1;
	grid[h[opMove]][opMove] = 1;
	h[opMove] --;
	displayGrid();
}
